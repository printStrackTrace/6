[toc]

# 绪论

## 数据结构概述

### 数据元素之间的四种关系
1. 集合关系：属于同一类，除此之外没有任何关系

2. 线性结构：数据之间存在一对一的线性关系

3. 树形结构：数据之间存在一对多的层次关系

4. 图状和网状结构：数据之间存在多对多的层次关系

   

### 数据结构的层次
1. 逻辑层次
        逻辑结构指数据元素之间逻辑关系的整体，是对操作对象的一种数学描述，是从具体问题中抽象出来的数学模型。
        逻辑关系指数据元素之间的关联方式或是邻接关系。
   
2. 物理层次
        物理结构指数据结构在计算机中的表示（即映像），也叫存储结构。其研究的是数据结构在计算机中的表示方法，包括数据结构中数据元素的表示以及数据元素之间关系的表示。
   
   ​     数据的存储结构除了存储元素，必须隐式或者显式地存储数据之间的逻辑关系。
   
   
   
### 数据元素在计算机中的两种表示方法：
   1. 顺序映像
                   借助元素在存储器中的相对位置来表示元素之间的逻辑关系，也就是把逻辑上相邻的元素存        储在物理上相邻的存储单元中，是一种基本的存储表示放法，借助于编程语言中的数组实现。
	
   2. 非顺序映像
	  ​   借助指示元素存储地址的指针表示元素之间的逻辑关系，也就是用一组任意的存储单元存储元素，不要去物理位置，元素之间的逻辑关系通过附设的指针字段表示，借助于指针类型实现。

### 数据结构的表示方式
- 数据结构研究的是 操作对象、关系、运算三者之间的关系
- 用三元组表示其抽象数据类型：
  ADT=（D,R,P）
  D表示数据对象，R表示关系集，P表示基本操作集
- 定义方式：
ADT 抽象数据类型名{
    数据对象：数据对象的定义
    数据关系：数据关系的定义
    基本操作：基本操作的定义
}ADT 抽象数据类型名；

## 算法与算法分析

### 算法 
- 定义：
    对特定问题求解步骤的一种描述，是指令的有限序列，一条指令包含一个或多个操作。
- 特征：
	1. 有穷性：在执行有穷步之后结束，每条指令在有穷时间内完成
	2. 确定性：每条指令有确定的含义，不存在二义性
	3. 可行性：算法描述的操作都是可以通过有限次的已经实现的基本运算来实现
	4. 输入：算法包含0个或者多个输入，输入取自于某个特定的对象集合
	5. 输出：算法包含1个或多个输出，输出是同输入有着某些关系的量
- 算法设计要求
	1. 正确性：满足具体问题的条件并解决具体问题
	2. 可读性
	3. 健壮性：具有容错处理
	4. 效率与存储量需求
- 算法效率度量方法
	1. 事后统计法
	    缺陷：必须先运行，并且时间依赖硬件，影响较大。
	
	2. 事前分析估算
	时间界限函数：f(x)=anx^n+……+a2x^2+a1x+a0  其中a0≠0
	时间复杂度：设数据规模n和所需时间y的关系为y=f(n)，则时间复杂度t关于n的函数t=g(n)是lim（n-->∞）时f(n)的同阶无穷大的最简形式。例如，f(n)=5x²+9x+1，则g(n)=x²。多数情况下，
	g(n)是最深处循环一条语句执行的次数（一条语句执行的次数又叫语句的频度）。时间复杂度的大小关系是：1<log2n<n<nlog2n<n^2<n^3<2ⁿ<n!<nⁿ。时间复杂度记作记作T(n)=o(f(n))。
	
	3. 空间复杂度
	
	  空间复杂度是程序从开始运行到结束所需的存储空间的度量，记作S(n)=o(f(n))。
	

## 课堂补充知识点

- realloc：参数为void*p和unsigned size，用于重新分配空间（新空间的指针为p），可以改大或者改小。可能沿用原来的空间，也可能开辟新的空间，复制数据，释放旧的空间。
- 指针引用结构体中的数据要用->，结构体名字引用其成员用.

# 线性表


## 定义 

- 由n个数据元素（节点）a1,a2......an组成的有限序列

- n也叫表的长度，n=0时叫空表，n≠0时线性表记作(a1,a2,......an)

- 这里的数据元素只是一个抽象的符号，具体含义在不同情况下不同

- 复杂的线性表：一个元素由若干个数据项构成，这样的数据元素被称为记录，含有大量记录的线性表又称为文件。

  一图中，每一横行是一个记录，包含着学号、姓名等数据项。

### 逻辑特征

1. 非空的线性表有且仅有一个开始节点a1，没有前进趋势，有且仅有一个后继a2

2. 有且仅有一个终端节点an，没有直接后继，有且仅有一个直接前驱an-1

3. 其余的内部节点ai（就是a1和an中间的）都有且仅有一个直接前驱和直接后继

     

### 存储结构

1. 顺序存储结构
   - 用一组地址连续的空间存放数据元素，逻辑上相邻元素物理上也相邻。即把线性表的逻辑节点按逻辑顺序依次存放在一组地址连续的存储单元里。
   - 优点：可以随机存取
   - 缺点：插入和删除元素时要移动大量数据元素
   - 若每个元素占用m个存储单元，所占空间的第一个地址作为数据元素的地址，并以此为参考点，则线性表中第i+1个元素的存储位置Loc(ai+1)和第i个元素的存储位置Loc(ai)满足关系Loc(ai)+m=Loc(ai+1)
  - 计算公式为：Loc(ai)=(i-1)\*m+Loc(a1)=Loc(a1)-m+i*m

2. 链式存储结构
   - 用一组任意的空间存放数据元素，逻辑上相邻的元素物理上不一定相邻
   - 优点：插入和删除元素时不需要移动数据元素，仅需要修改指针值
   - 缺点：不能随机存取

所以，当线性表很少进行删除、插入的操作时，选顺序存储结构，反之选择链式结构

## 顺序表

### 定义顺序表

- 三要素：
   1. 存储空间首地址elem
   2. 存储空间大小 MaxSize
   3. 当前数据元素个数 length

- 顺序表的类定义

- ~~~ c
   #define MaxSize 100  //定义存储空间大小
   #define LISTINCREMENT 10//定义增量空间
   typedef struct{
       ElemType data[MaxSize];//指向存放数据的一整串空间首地址
       int length;
   }SqList;
   ~~~
   
- 
  
   ~~~ c
   void CreatList(SqList *&L,ElemType a[],int n){//SqList *&L为传递顺序表指针，
       //整体建立顺序表
       //L是指向顺序表的一个指针
       //之所以在L前面+&，是为了把传递进来的变量的地址复制一份给函数体内的变量，如此一来对函数内该变量的操作就相当于对主函数内变量的操作了
       //输出型参数均加&，无论参数值是否改变
       L=(SqList *)malloc(sizeof(Sqlist));//开辟一个内存单元存放一个结构体作为数据元素
       int i;
       for(i=0;i<n;i++)//结构体中有数据i个，以及int length
           L->data[i]=a[i];
       L->length=n;
   }
   ~~~

- 创建链表用malloc，修改空间大小用realloc。

### 顺序表的基本操作

#### 初始化顺序表

- 初始化是从无到有建立空的顺序表，在构造函数中实现

- 代码为：

  ~~~  c
  void InitList(SqList* &L)//创建顺序表指针L，指向对应的顺序表
  {
      L=(SqList*)malloc(sizeof(SqList));
      L->length=0;
  }
  ~~~

#### 销毁顺序表
- 释放顺序表所占用的内存空间，在析构函数中实现
- 代码为：

  ~~~ java
  void DestroyList(SqList* &L)
  {
      free(L);
  }
  ~~~

#### 判断是否为空表

- 代码为：

   ~~~ c
   bool ListEmpty(SqList* L)
   {
   	return(L->length==NULL);    
   }
   ~~~

#### 求顺序表长度

- 代码为：

   ~~~ c
   int ListLength(SqList* L)
   {
       return(L->length);
   }
   ~~~

#### 输出线性表

- 代码为：

   ~~~ c
   void DispList(SqList *L)
   {
       int i;
       if(ListEmpty(L))return;
       for(i=0;i<L->length;i++)
       {
           printf("%c",L->data[i]);
       }
       printf("%\n");
   }
   ~~~

#### 查找第i个元素的值并返回给e

- 代码为：

   ~~~ c
   bool GetElem(SqList *L,int i,ElemType &e)//i是逻辑次序，使用时要-1
   {
       if(i<1||i>L->length)return false;
       e=L->data[i-1];
       return true;
   }
   ~~~

- 显然，该算法的时间复杂度为o(1)，这说明顺序表具有随机存取特性

#### 查找顺序表中是否有e，若有返回e的逻辑位序，否则返回0

- 代码为：

   ~~~ c
   int LocateElem(SqList *L,ElemType e)
   {
       int i=0;
       while(i<L->length&&L->data[i]!=e)
           i++;
       if(i>=L->length)return 0;
       else return ++i;
   }
   ~~~

#### 插入数据元素

- 在顺序表中的某个位置插入一个新的数据元素时，表的长度会发生改变。该算法的时间消耗主要体现在数据元素的循环后移上，该语句的执行次数(也就是移动的数据元素个数)是n-i+1
- 代码为：

  ~~~ java
  bool ListInsert(SqList *&L,int i,ElemType e)
  {
      int j;
      if(i<1||i>length+1)return false;
      i--;
      for(j=L->length;j>i;j--)
      {
          L->data[j]=l->data[j-1];
      }
      L->data[i]=e;
      L->length++;
      return true;
  }
  ~~~
  
  - 复杂度分析：
  
    ​	最坏情况是o(n)，最好情况是0。
  
    ​	平均情况：共有n+1个地方可以插入元素，若等概率，每种情况的概率是n+1，此时需要把ai到an都后移，也就是n-i+1次。那么平均情况的此数为 
    $$
    pi*\sum_{i=1}^{n+1}n-i+1=\frac{n}{2}
    $$
    因而算法时间复杂度为o(n)

#### 删除顺序表的第i（逻辑位序）个元素

- 代码为：

   ~~~ c
   bool ListDelete(SqList *&L,int i,ElemType e)
   {
       if(i<1||i>L->length)return false;
       i--;
       int j;
       for(j=i;j<=length-2;j++)
           L->data[j]=L->data[j+1];
       L->length--;
       return true;
   }
   ~~~
   
   - 复杂度分析
   
     ​	平均移动此数为（n-1)/2，复杂度为o(n)

### 例题

1. 已知长度为n的线性表A采用顺序存储结构。设计一个时间复杂度为o(n)，空间复杂度为o(1)的算法删除线性表中值为x的元素

   删除再排序，时间复杂度是n²，新建空间存放线性表空间复杂度是n。

   由于新的线性表肯定不会大于原有的线性表，因而可以考虑用原有的空间存放新的线性表。

   - 方法1：遍历线性表，若遇到不是x的元素，则把它放在k位置，k初始值为0，每放一个k+1，若是遇到x，则跳过。最后把线性表的长度赋值为k即可。
   - 方法2：遍历线性表，若遇到x，则另记录x个数的k增加1，k初始值也为0。若遇到不是x的元素，则用它覆盖下标比他小k的元素

2. 设顺序表L有11个整数。设计一个算法，以第一个数为分界线，比他大的放他前面，比他小的放他后面，相等的放一起。

   - 代码为：

   ~~~ c
   #include <stdio.h>
   void main()
   {
    int a[]={4,-1,5,1,9,3,5,3,2,1,7};//length=11
    int i;
    int j=10;
    for(i=1;i<11;)
    {
        if(a[i-1]==a[i])i++;
        if(a[i-1]>a[i])
        {
           int t=a[i-1];
           a[i-1]=a[i];
           a[i]=t;
           i++;
        if(j<i)break;
           continue;
        }
        if(a[i-1]<a[i])
        {
            int t=a[j];
            a[j]=a[i];
            a[i]=t;
            j--;
        	if(j<i)break;
        }
    }
    for(i=0;i<11;i++)
        printf("%d ",a[i]);
   }
   
   ~~~

或

~~~ c
#include <stdio.h>
void main()
{
    int a[]={6,9,8,3,1,9,7,66,8,7,7};
    while(i<j)
    {
        while(i<j&&a[j]>=p)
            j--;
        if(i<j)
            a[i]=a[j];
        while(i<j&&a[i]<p)
            i++;
        if(i<j)
            a[j]=a[i];
    }
    a[j]=p;
    for(p=0;p<l;p++)
        printf("%d ",a[p]);
}

~~~

## 链表

### 基本概念

- 链表，线性表的链式存储结构
- 不同于顺序表，链表需要地址来体现逻辑关系，因而在数据元素中增加了指向下一个数据元素的指针，也叫指针域。
- 如果只增加了指向每个数据元素（节点）下一个节点的指针域，即为单链表，增加了指向下一个和前一个节点的指针域即为双链表

- 单链表的存储结构如图：

  

- 增加头节点的好处：
  - 头节点和其他节点结构相同，操作一致，无序对首节点进行特殊处理
  - 无论链表是否为空都有头节点，这让空表和非空表的处理统一

- 存储密度

  - 链表的空间一方面用来存放数据，一方面存放指针，单个节点的数据占用空间和单个节点占用的总空间的比值即为存储密度
  - 顺序表的存储密度为100%，因为他不放指针
  - 链表的密度始终小于1

### 单链表

#### 定义

~~~ c
typedef struct LNode
{
    ELemType data;
    struct LNode *next;//这指向的是下一个节点	
}LinkList,*LinkList;//LinkList和LNode*等价
//比如声明一个链表指针 可以是 LinkList p;或者LNode *p;
~~~

- 单链表的访问直接往前不能往后，因为当前节点的指针指向下一个节点而没有指针指向上一个。

#### 基本操作

##### 创建单链表

- 头插法：从空表开始，创建头节点。依次读取数据数组中的元素生成新节点，再插入到当前链表的表头上。
- 代码为：

~~~ c
void CreatListF(LinkList *&L,ElemType a[],int n)
{
    LinkList *s;
    int i;
    L=(LinkList *)malloc(sizeof(LinkList));
    L->next=NULL;
    for(i=0;i<n;i++)
    {
        s=(LinkList *)malloc(sizeof(LinkList));
        s->data=a[i];
        s->next=L->next;
        L->next=s;
    }
}
~~~

- 尾插法：从空表开始创建头节点，读取数组数据生成新节点，把新节点接在表尾上。
- 代码为：

~~~ c
void CreatListR(LinkList *&L,ElemType a[],int n)
{
    LinkList *s,*r;
    int i;
    L=(LinkList *)malloc(sizeof(LinkList));
    r=L;
    for(i=0;i<n;i++)
    {
        s=(LinkList *)malloc(sizeof(LinkList));
        s->data=a[i];
        r=s;
        r->next=s;
    }
    r->next=null;
}
~~~

#### 判断链表是否为空表

- 代码为：

~~~ c
bool ListEmpty(LinkList *L)
{
    return(L->next==null);
}
~~~

#### 求链表长度

- 在顺序表中，长度L是被储存的，读取即可
- 代码为：

~~~ c
int ListLength(LinkList *L)
{
    int n=0;
    LinkList *p=L;
    while(p->next!=null)
    {
        p=p->next;
        n++;
    }
    return n;
}
~~~

#### 输出单链表

~~~ c
void DispList(LinkList *L)
{
    LinkList *p=L;
    while(p!=null)
    {
        p=p->next;
        printf("%d ",p->data);
    }
    printf("\n");
}
~~~

#### 查找链表中第i个元素

~~~ c
bool GetElemi(LinkList *L,int i,ElemType &e)
{
    int j=0;
    LinkList *p=L;
    while(j!=i&&p!=null)
    {
        p=p->next;
        j++;
    }
    if(p!=null)
    {
        e=p->data;
        return true;
    }
    else
        return false;
}
~~~

#### 插入数据元素

~~~ c
bool ListInsert(LinkList *&L,int i,ElemType e)
{
    int j=0;
    LinkList *p=L;
    while(j!=i-1&&p->next!=null)
    {
        j++;
        p=p->next;
    }
    if(p==null)return false;
    s=(LinkList *)malloc(sizeof(LinkList));
    s->data=e;
    s->next=p->next;
    p->next=s;
    return true;
}
~~~

### 双链表

#### 定义

- 相比于单链表，增加了指向前驱节点的指针域

- 相比于单链表，双链表可以从任意节点出发，找到其他任意位置的节点。

- 代码：

  ~~~ c
  typedef struct DNode{
      ElemType data;
      struct DNode *pi;//前驱节点
      struct DNode *next;//后驱节点
  }DLinkList;
  ~~~

  #### 操作
  
  ##### 插入元素
  
  - 在p指针所指节点后面插入
  
  ~~~ c
  s->next=p->next;
  p->next->pi=s;
  s->pi=p;
  p->next=s;
  ~~~
  
  ##### 删除元素
  
  - 删除p指针所指节点后面的节点
  
  ~~~ c
  p->next->next->pi=p;
  p->next=p->next->next;
  ~~~
  
  
  
  ##### 建立双链表
  
  - 头插法
  
  ~~~ c
  void CreateListF(DLinkList *&L,ElemType a[],int n){
      DLinkList *s;
      int i;
      L=(DLinkList *)malloc(sizeof(DLinkList));
      L->pi=L->next=NULL;
      for(i=0;i<n;i++){
      	s=(DLinkList *)malloc(sizeof(DLinkList));
          s->data=a[i];
          s->next=L->next;
          if(L->next!=NULL)
              L->next->pi=s;
          L->next=s;
          s->pi=L;
          /*
          s->pi=L;
          s->next=L->next;
          if(L->next!=NULL)
          	L->next->pi=s;
          L->next=s;
          */
  	}
  }
  ~~~
  
  - 尾插法
  
   ~~~ c
    void CreateListR(DLinkList *&L,ElemType a[],int n){
    	DLinkList *s,*r;
        int i;
        L=(DLinkList *)malloc(sizeof(DLinkList));
        r=L;//r指针始终指向尾节点，开始时直线头节点
        for(i=0;i<n;i++){
            s=(DLinkList *)malloc(sizeof(DLinkList));
            s->data=a[i];
            r->next=s;s->pi=r;
            r=s;
        }
        r->next=NULL;
    }
   ~~~
  
    ##### 插入
  
    - 插入元素作为第i个元素。
  
   ~~~ c
      bool ListInsert(DLinkList *&L,int i,ElemType e){
          int j=0;
          DLinkList *p=L,*s;
          while(j<i-1&&p!=NULL){
              j++;
              p=p->next;
          }
          if(p==NULL)return false;
          s=(DLinkList *)malloc(sizeof(DLinkList));
          s->data=e;
          s->next=p->next;
          if(p->next!=NULL)
              p->next->pi=s;
          s->pi=p;p->next=s;
          return true;
      }  
   ~~~
  
  ### 循环链表
  
  - 循环单链表：把表中尾结点改为指向头节点，从而形成一个环，由此表中任意节点出发可以找他其他任意节点
  
  - 循环双链表：形成两个环
  
  ###  有序表
  
  - 即所存放元素按一定顺序排列
  - 可以是顺序表，也可以是链表

  ###  二路归并算法

  - 引例：现有有序表LA和LB，元素同为递增，设计一个算法把他们合并成LC
  
    <img src="C:\Users\25024\Desktop\数据结构\image-20220813160654873.png" alt="image-20220813160654873" style="zoom: 50%;" />

- i和j分别指向两个链表的收个元素，小的那个复制到LC，并把复制的元素指针往后移动，直到i和j移到末尾
- 时间复杂度为o(m+n)，空间复杂度为o(m+n)
- 来道真题：

![image-20220813162149785](C:\Users\25024\Desktop\数据结构\image-20220813162149785.png)

- 题目让找中位数，并没有要求合并，所以压根不需要开辟空间存放，只需要找到第L/2大的数就可以了，用k存放第n大的数，用二路归并的思想循环，直到n=L/2，此时的k就是中位数。

## 单链表和顺序表练习题

1. 一个带头节点的单链表存放了n了元素，头节点指针为L，请把奇数位置元素放在以L1为头节点的单链表里，把偶数位置元素放在以L2为头节点的单链表里，要求L1和L相同。
2. 已知一个长度为n的int数组，存放的元素只有0,1,2，随机排列，设计一个时间复杂度为o（n）的算法，把他们改成按0,1,2排列（0放在一起，1放在一起，2放在一起）
3. 第二题的存放手段改为用单链表，要求同

# 栈和队列

## 栈

### 定义

- 栈是一种只能在某一端进行删除和插入操作的线性表

- 只能是选定的那端可以操作，并且只有删除和插入操作

- 类比一个死胡同，只有出口可以允许人的进和出

- 允许操作的端叫栈顶，另一端叫栈底

- 没有元素的栈叫空栈

- 插入操作叫进栈/入栈，删除操作叫退栈/出栈

- 因此，后进栈的元素先出来，栈也叫“后进先出”表

- 栈有两类存储结构，一类同顺序表，一类同链表

### 顺序栈基本操作

  #### 创建栈

- 顺序栈

- ~~~ c
  typedef struct{
      ELemType data[MaxSize];//MaxSize为最大容量
      int top;//栈顶指针
  }SqStack;
  ~~~

- 结构示意图：

![image-20220813184739349](C:\Users\25024\Desktop\数据结构\image-20220813184739349.png)

- top总是指向栈顶元素，初始值为-1
- 当top=MaxSize-1时不能再进栈（满栈）
- 进栈时top+1，出栈top-1
- 空栈：top=-1；满栈：top=MaxSize-1
- 初始化：

~~~ c
void InitStack(SqStack *&s){
    s=(SqStack *)malloc(sizeof(SqStack));//强制转换的时候，系统就已经把你申请的内存分块分配给结构体的成员
    s->top=-1;
}
~~~



#### 销毁栈

- 释放s指向的存储空间即可

- ~~~ c
  void DistroyStack(SqStack *&s){
      free(s);
  }
  ~~~

  

#### 判断是否为空栈

~~~ c
bool StackEmpty(SqStack *s){
    return (s->top==-1);
}
~~~



#### 删除元素（出栈）

~~~ c
bool Pop(SqStack *&s,ElemType &e){
    if(s->top==-1)return false;
    e=s->data[s->top];
    s->top--;
    return true;
}
~~~



#### 插入元素（进栈）

~~~ c
bool Push(SqStack *&s,ElemType e){
    if(s->top==MaxSize-1)return false;//先判断是否是满栈
    s->top++;
    s->data[s->top]=e;
    return true;
}
~~~



#### 提取栈顶元素

~~~ c
bool GetTop(SqStack *s,ElemType &e){
    if(s->==-1)return false;
    e=s->data[s->top];
    return true;
}
~~~

### 链栈基本操作

- 存储结构

<img src="C:\Users\25024\Desktop\数据结构\image-20220814091258836.png" alt="image-20220814091258836" style="zoom:60%;" />

- 用s指针指向头节点，也就是栈顶前面的节点
- 栈空：s->next=NULL；栈满条件不考虑
- 因而在链栈中，节点的定义是

~~~ c
typedef struct linknode{
    ElemType data;
    struct linknode *next;
}LiStack;
~~~

#### 初始化链栈

~~~ c
void CreatStack(LiStack *&s){
    s=(LiStack *)malloc(sizeof(LiStack));
    s->next=NULL;
}
~~~

#### 销毁链栈

~~~ c
void DestroyStack(LiStack *&s){
    LiStack *p=s;
    *q=s->next;
    while(q!=NULL){
        free(p);
        p=q;
        q=p->next;
    }
    free(p);
}
~~~

#### 判断空栈

~~~ c
bool EmptyStack(LiStack *s){
    return (s->next==NUll);
}
~~~

#### 进栈

~~~ c
void Push(LiStack *&s,ElemType e){
    LiStack *p;
    p=(LiStack *)malloc(sizeof(LiStack));
    p->next=s->next;
    s->next=p;
}
~~~

#### 出栈

~~~ c
bool Pop(LiStack *&s,ElemType e){
    LiStack *p;
    if(s->next==NUll)return false;
    p=s->next;
    e=p->data;
    s->next=p->next;//一定要在free（p）的前面 否则会丢失数据
    free(p);
    return true;
}
~~~



## 队列

### 定义

- 是一种运算受限的线性表

- 队列的一端只能用来删除，另一端只能用来插入

- 进行删除操作（出队/离队）的一端叫队头/队首，进行插入操作（进队/入队）的一端叫队尾

- 同样，队列也有线性结构和链式结构

### 线性结构队列

- 顺序队的结构体为：

- ~~~ c
  typedef struct{
      Elemtype data[MaxSize];
      int front,rear;//队首队尾指针，开始时都指向-1
  }SqQueue;
  ~~~

- **front和rear的指向特点是：data[front+1]所指元素是下一个出队的，data[rear]所指元素是刚刚进队的，元素进队，rear+1，元素出队，front+1**

- 当rear=MaxSize-1的时候队满，不可进队

- 队空条件：rear==front

### 基本操作

#### 		初始化队列

~~~ c
void InitQuene(SqQuene *&q){
    q=(SqQuene *)malloc(sizeof(SqQuene));
    q->front=q->rear=-1;
}
~~~



#### 		销毁队列

~~~ c
void InitQuene(DestroyQuene *&q){
    free(q);
}
~~~



#### 		判断空队列

~~~ c
bool QueneEmpty(SqQuene *q){
    return q->front==q->rear;
}
~~~



#### 		进队列

~~~ c
bool EnQuene(SqQuene *&q,ElemType e){
    if(q->rear==MaxSize-1)return false;
    q->rear++;
    q->data[q->rear]=e;
    return true;
}
~~~



#### 		出队列

~~~ c
bool DeQuene(SqQuene *&q,ElemType e){
    if(q->front==q->rear)return false;
    q->front++;
    e=q->data[q->front];
    return true;
}
~~~



- 注意：队列的满，不一定是真的满，因为进队是从上进队，出队是从下出队，当rear指向顶上方元素的时候就是满（也就是rear==MaxSize-1），这不代表队列全部位置都有元素填充，front所指位置可以是空着的，这种溢出叫假溢出

#### 环形队列

##### 相关定义

- 为了解决这一空间浪费问题，出现了环形队列：

  <img src="C:\Users\25024\Desktop\数据结构\image-20220816174356538.png" alt="image-20220816174356538" style="zoom:50%;" />

- 需要注意的是，在存储空间中并不是以环形结构存储，只是我们让rear和front两个指针循环变动，具体操作是：rear=(rear+1)%MaxSize和front=(front+1)%MaxSize

- 以图为例，出队一个元素front++，a出去，front指向a所在内存单元，再出去3个元素，队列空，rear和front相等。因此空队列的等价条件是rear==front

- 以图为例， 如果现在再进队一个元素，rear和front相等了，但是队列是满队列而不是空队列，这使得rear==front这个条件出了问题。

- 因此队满条件更正为(rear+1)%MaxSize=front。也就是图示情况认为是队满，这么操作会丢失一个内存单元。

  

##### 队头队尾指针和数据个数的关系

- 已知了front和rear，可以算出已经存储的数据个数count：**count=（rear-front+MaxSize）%MaxSize**。

- 上述问题会遇到以下两种情况：

  <img src="C:\Users\25024\Desktop\数据结构\image-20220908091225726.png" alt="image-20220908091225726" style="zoom: 25%;" />

- **rear=(front+count)%MaxSize**

- **front=(rear-count+MaxSize)%MaxSize**

	##### 结构体设计
	
	~~~ c
	typedef struct{
	    ElemType data[MaxSize];
	    int front;
	    int count==0;
	}QuType;
	~~~
	
	##### 操作要素
	
- 队空：count==0；

- 队满：count==MaxSize；注意！！这里的队满条件和之前的不一样，因为之前需要区分队满和队空，这里因为用到了count所以不需要区分，导致之前的循环队列可以用MaxSize-1个数据，现在可以用MaxSize个

- 进队：rear=（rear+1）%MaxSize；

- 出队：front=（front+1）%MaxSize；

  ##### 相关操作代码
  
- 初始化

- ~~~ c
  void InitQuene(Qutype *&qu){
      qu=(Qutype *)malloc(sizeof(QuType));
      qu->front=0;
      qu->count=0;
      //没有rear哦
  }
  ~~~

- 进队

- ~~~ c
  bool EnQuene(Qutype *&qu,ElemType x){
      int rear;//局部变量，不是队列结构体中存在的，临时队尾指针
      if(qu->count==MaxSize)return false;//如果满了，返回false
      rear=(qu->front+qu->count+MaxSize)%MaxSize;//求出队尾位置
      rear=(rear+1)%MaxSize;//rear往后移动
      qu->data[rear]=x;
      qu->count++;
      return true;
  }
  ~~~

- 出队

- ~~~ c
  bool DeQuene(Qutype *&qu,ElemType &x){
      if(qu->count==0)return false;
      qu->front=(qu->front+1)%MaxSize;
      x=qu->data[qu->front];
      qu->count--;
      return true;
  }
  ~~~

### 链式结构队列

- 结构图：

  <img src="C:\Users\25024\Desktop\数据结构\image-20220920002828080.png" alt="image-20220920002828080" style="zoom:33%;" />

- 通常情况，额外使用一个节点，存放front和rear（队头队尾指针）。因此链队的节点有两种，头节点单独为一种存放指针的特殊节点，其余节点为存放数据和next指针的节点。

#### 节点结构体设计

~~~ c
//数据元素结构：
typedef struct qnode{
    ElemType data;
    struct qnode *next;
}qn;

//头节点结构：
typedef struct{
    qn *front;
    qn *rear;
}Head;
~~~

#### 操作要素

- 队空：front==rear==NULL;

- 队满：满不了

- 进队：插到队尾，即开辟新的空间，存放元素，把当前队尾的next修改为开辟的空间的指针，最后移动队尾指针。

- 出队：free队头指针空间

#### 相关操作

##### 初始化链队

~~~ c
	void InitQueue(LiQueue *&q){
        q=(Head *)malloc(sizeof(Head));
        q->front=NULL;
        q->rear=NULL;
    }
~~~

##### 销毁链队

~~~ c
void DestroyQueue(LiQueue *&q){
    qn *p=q->front,*r;
    if(p!=NULL){
        r=p->next;
        while(r!=NULL){
            free(p);
            p=r;r=r->next;
        }
    }
    free(q);
}
~~~

##### 判断空队列

~~~ c
bool QueneEmpty(qn *q){
    return (q->rear==q->NULL);
    //或  return (q->front==q->NULL);
}
~~~

##### 进队

- 注意判断当前链队是否为空

~~~ c
void enQueue(qn *&q,ElemType e){
    qn* p;
    p->data=e;
    p->next=NULL;
    if(QueneEmpty(q))q->front=q->rear=p;
    else {
        q->rear->next=p;
        q->rear=p;
    }
}
~~~



## 栈和队列求解迷宫问题

# 串

## 概念

- 由0个或多个**字符**组成的有限序列，是线性表的一种
- “a1,a2......an”
- 子串：一个串中任意连续字符组成的子序列称为子串，包含空串
- 真子串指不包含其本身的子串

## 存储结构

- 分为链串和顺序串

- ~~~ c
  #define MaxSize 100
  typedef  struct{
      char data[MaxSize];
      int length;
  }SqString;
  //顺序串
  ~~~

- ~~~ c
  typedef struct snode{
      char data;
      struct snode *next;
  }LiString;
  //链串
  ~~~

  

## 模式匹配（KMP）

- 

# 递归

## 定义 

- 在定义一个过程或函数时，出现直接或间接调用自己的成分，称之为递归，直接调用称直接递归，间接调用称间接递归（例如定义函数f1时用到了f2，f2里有f1）
- 一个间接递归总能转换成直接递归
- 若出现递归的语句在一个函数末尾，则称为直接递归函数的尾递归
- 尾递归函数可以用循环语句转换成等价的非递归算法
- 其他递归函数可以用栈转换成等价的非递归算法

## 使用场景

1. 定义本身递归，如斐波那契数列，阶乘
2. 数据结构递归，如不带头节点的单链表（L指向a1，L和L->next对应n和n-1，继续往下可以一直分解到最后一个元素）
3. 求解问题的方法递归

- 递归时处理的大小问题一定是相似的，把大问题逐渐分解成可以直接求解的小问题

## 递归模型

- 递归模型总是由递归出口和递归体两部分组成
- 递归出口反应递归到什么时候结束，一般形式为 f（m）=n，mn为常数，递归问题可以有很多出口
- 递归体确定递归求解时的递推关系，一般形式为f（Sn)=g(f(Sn-1)+f(Sn-2)+……+f(Si)+c)，可简化为f（Sn)=g(f(Sn-1)+c）

## 处理过程

- 

<img src="C:\Users\25024\Desktop\数据结构\image-20221020150131028.png" alt="image-20221020150131028" style="zoom:33%;" />

- 部分复杂问题可能需要多次分解，如

  <img src="C:\Users\25024\Desktop\数据结构\image-20221020150254061.png" alt="image-20221020150254061" style="zoom:33%;" />

## 递归算法设计步骤 

1. 设计求解问题的递归模型
   1. 对原问题f（s）分析，称为大问题，假设出合理的小问题f（s’）
   2. 假设f（s’）可解，找出***f（s）和f（s’）的关系***（递归体）
   3. 确定一种特殊情况，问题可直接得解，得出递归出口
2. 转换成对应的递归算法



# 数组和稀疏矩阵

## 数组

- 对于一维数组A，可以表示为A={a1,a2......an}；其中ai为元素
- 对于二维数组A，可以表示为A={A1,A2......An}；其中Ai为一维数组

### 数组的地址



## 稀疏矩阵



# 树和二叉树

## 树

### 树的定义

- 定义1：T={D,R};D包含了n个元素，n=0时为空树，且满足以下条件

  1. 有且仅有一个特殊节点d0，他没有前驱节点，d0又称为树的根节点
  2. 除了根节点以外，其他所有节点有且仅有一个前驱节点
  3. 所有节点有0个或多个后继节点

- 定义2:递归定义。

  1. n=0，空树

  2. n>0，其中存在一个唯一节点作为树的根节点（root），其余节点可分为m个互不相交的有限子集，T1,T2......Tm，而每个子集本身又是一棵树，称为根节点root的子树
  
  - 树中所有节点有一种层次关系

    

### 树的逻辑表示形式     

1. 树形表示法：用一棵倒着的树来表示

   <img src="C:\Users\25024\Desktop\数据结构\image-20221027210744936.png" alt="image-20221027210744936" style="zoom:33%;" />

2. 文氏图表示法：用集合以及集合的包含关系表示：

<img src="C:\Users\25024\Desktop\数据结构\image-20221027210845277.png" alt="image-20221027210845277" style="zoom:33%;" />

3. 凹入表示法：用线段的凹凸关系表示结构

<img src="C:\Users\25024\Desktop\数据结构\image-20221027210956018.png" alt="image-20221027210956018" style="zoom:33%;" />

4. 括号表示法：用一个字符串表示

<img src="C:\Users\25024\Desktop\数据结构\image-20221027211042105.png" alt="image-20221027211042105" style="zoom:33%;" />

<img src="C:\Users\25024\Desktop\数据结构\image-20221027211101722.png" alt="image-20221027211101722" style="zoom:33%;" />



### 树的基本术语

1. 节点的度和树的度
   - 树中一个节点的子树的个数称为该节点的度
   - 树中各节点最大的度就是树的度
   - 度为m的树称为m次树或m叉树

2. 分支节点于叶节点
   - 度不为0的节点称为非终端节点，也叫分支节点，度为0的节点称为终端节点或叶（子）节点
   - 度为x的节点称为x分支节点
3. 路径和路径长度
   - 两个节点di和dj节点序列（di,di1,di2...dj）称为路径
   - 节点序列（di,di1,di2...dj）所包含的节点个数-1即为路径长度
4. 亲戚节点
   - 孩子节点：一个节点的后继节点称为这个节点的孩子节点
   - 双亲节点：一个节点的前驱节点称为这个节点的双亲/父亲节点
   - 兄弟节点：具有同一双亲节点的几个节点互为兄弟节点
   - 子孙节点：一个节点的所有子树中所有节点称为这个节点的子孙节点
   - 祖先节点：从根节点到一个节点所需经过的节点称为这个节点的祖先节点
5. 节点层次和树的高度
   - 树中每个节点都处于一个层次上，节点的层次从跟节点开始定义，根节点为第一层，它的孩子节点为第二层，以此类推。一个节点所在层次等于其双亲节点所在层次+1
   - 树中，层次的最大值称为树的高度/深度
6. 有序无序树
   - 树中各节点的子节点排列而非组合，次序不可随意变换，即为有序树
   - 反之，为无序树
7. 森林
   - n个互不相交的树的集合
   - 把根节点的子节点个数不少于2的树的根节点删除，这棵树就成了森林
   - 反之，把这n个互不相交的树构成的森林加上一个根节点，森林就成了树 

### 树的性质

1. 所有节点的度之和为分支个数，再加一为所有节点个数

1的例题：![image-20221027221551179](C:\Users\25024\Desktop\数据结构\image-20221027221551179.png)

解：

![image-20221027221614211](C:\Users\25024\Desktop\数据结构\image-20221027221614211.png)

2. 度为m的树中，第i层上至多有m^(i-1)个节点（i>=1）
2. 高度为h的m次树至多有

$$
\frac{m^h-1}{m-1}(等比数列求和)个节点
$$

4. 具有n个节点的m次树的最小高度为

$$
log_m(n(m-1)+1)  向上取整
$$



### 树的基本运算

1. 树的遍历
   - 以某种方式访问树中的每个元素，每个元素仅访问一次。
   - 多种遍历方法：
     1. 先根遍历：若树不为空，先访问根节点，然后依次先根遍历其他子树（递归）<img src="C:\Users\25024\Desktop\数据结构\image-20221028101607099.png" alt="image-20221028101607099" style="zoom:33%;" />
     2. 后根遍历：若树不为空，先访问其他子树，然后访问根节点（递归）<img src="C:\Users\25024\Desktop\数据结构\image-20221028101716292.png" alt="image-20221028101716292" style="zoom:33%;" />
     3. 层次遍历：按照自上而下，自左至右的顺序访问树中每个节点<img src="C:\Users\25024\Desktop\数据结构\image-20221028101858217.png" alt="image-20221028101858217" style="zoom:33%;" />

### 树的存储结构

1. 双亲存储结构

~~~ c
typedef struct {
    ElemType data;
    int parent;//指向双亲的位置，这是伪指针
}PTree[MaXSize];
~~~

2. 孩子链存储结构

   - 每个节点都存在n个指针，每个指针指向该节点的孩子节点，n为树的度，没有为空指针

   - ~~~ c
     typedef struct node{
         ElemType data;
         struct node *sons[MaxSons];
     }TSonNode;
     ~~~

3. 孩子兄弟链存储结构

   - 每个节点包含三个域：数据元素域、第一个孩子节点指针域、一个兄弟节点指针域（即把所有兄弟连成链表）

   - ~~~ c
     typedef struct tnode{
         ElemType data;
         struct tnode *hp;
         struct tnode *vp;
     }TSBNode;//固定只有2个节点
     ~~~

## 二叉树

### 定义

- 二叉树是有限节点的集合，集合可以为空，若不为空，根节点包含一个两棵互不相交的树，分别是左子树和右子树，即二叉树

- 五种基本形态：

  1. 空树
  2. 只含根节点
  3. 左子树为空
  4. 右子树为空
  5. 左右子树都不为空

- 四种表示方法都可以表示

- 两种特殊的二叉树

  1. 满二叉树

     - 所有分支节点都双分节点

     - 所有叶子节点都在二叉树的底层

     - 层序编号：从上到下从左到右，如图：<img src="C:\Users\25024\Desktop\数据结构\image-20221029180729824.png" alt="image-20221029180729824" style="zoom:33%;" />

     - 高度为h的满二叉树节点个数为
       $$
       2^h-1
       $$
     - 若高度为h的二叉树含有这么多个节点，则为满二叉树
  
  2. 完全二叉树
  
     - 度数小于2的节点仅存在于最后两层
     - 最下面一层的叶子节点依次排列在该层最左边的位置上
     - 除去最后一层，上面的所有节点构成的树是满二叉树
     - 一个完全二叉树可以由一个满二叉树删去最右边的若干个叶子节点得到
     - <img src="C:\Users\25024\Desktop\数据结构\image-20221029181641792.png" alt="image-20221029181641792" style="zoom:33%;" />
  
  ### 性质
  
  1. 非空二叉树上叶子节点的个数等于双分支节点个数加1:
  
  $$
  n_0=n_2+1\\ \\ \\证明：\\度之和=分支数=n_1+n_2\\分支数=n-1\\n=n_0+n_1+n_2
  $$
  
  2. 非空二叉树上第i层最多有
  
  $$
  2^{i-1}个节点
  $$
  
  3. 高度为h的二叉树至多有
  
  $$
  2^h-1个节点
  $$
  
  4. 
  
     1. 对于一个完全二叉树，度为1的节点个数要么为0要么为1，这取决于该树节点个数n的奇偶性：
  
        n为奇数，n1=0，因为除去根节点，其他总是成双成对
  
        n为偶数，n1=1。
  
     2. 给完全二叉树层序编号，对于编号为i的节点，若i<=n/2（向下取整）则该节点为分支节点，否则为叶子节点
  
     3. 除根节点外，编号为i的节点的双亲节点的编号为i/2（向下取整）
  
     4. 编号为i的节点的左子节点编号为2i，右子节点的编号为2i+1
  
  ### 二叉树和树、森林之间的转换
  
  1. 树转二叉树：
     1. 连接所有兄弟节点<img src="C:\Users\25024\Desktop\数据结构\image-20221029193420973.png" alt="image-20221029193420973" style="zoom:25%;" />
     2. 保留最左边的节点与其双亲节点之间的连线，删除剩下的兄弟节点与双亲节点的连线<img src="C:\Users\25024\Desktop\数据结构\image-20221029193700129.png" alt="image-20221029193700129" style="zoom:25%;" />
     3. 顺时针旋转45°<img src="C:\Users\25024\Desktop\数据结构\image-20221029193722461.png" alt="image-20221029193722461" style="zoom:25%;" />
  2. 多棵树转二叉树
     1. 按照上述方法把每棵树转成二叉树
     2. 组合：把第二棵二叉树的根节点作为第一棵二叉树根节点的右子节点，再把第三棵树的根节点作为第二棵树根节点的右子节点，以此类推
     3. 或：给所有的树加上一个节点形成新的树，再按照上述方法转换成二叉树，完成后删除新增的根节点。
  3. 二叉树还原为森林、树
     
     //第八周第三讲后半 二叉树转树有错 略

### 二叉树的存储结构

#### 	顺序存储

- 性质四：完全二叉树的层序编号为：<img src="C:\Users\25024\Desktop\数据结构\image-20221031230253114.png" alt="image-20221031230253114" style="zoom:25%;" />
- 依据此规律用顺序表存储：<img src="C:\Users\25024\Desktop\数据结构\image-20221031230346822.png" alt="image-20221031230346822" style="zoom:25%;" />
- 不用下标为0的元素
- 对于非完全二叉树，把他视为完全二叉树，补齐空节点再编号
- 空节点用特殊字符如#表示

	#### 	顺序存储性质

- 适合完全二叉树，不适合退化的二叉树，有较大的空间浪费
- 由于完全二叉树的性质4，易于找到一个节点的双亲和孩子节点

#### 链式存储

- ~~~ c
  typedef struct node {
      ElemType data;
      struct node *lchild,*rchild;
  }BTNode;
  ~~~

- 又叫 二叉链

#### 链式存储性质

- 除了指针外，相对节省空间，占用的空间大小取决于节点个数而非树的形状
- 容易找到孩子节点，不方便找到双亲节点
- n个节点即2n个指针域
- 分支数为n-1即非空指针域为n-1
- 所以空指针域个数为n+1个

### 二叉树的基本运算和实现

1. 创建二叉树
   - 由正确的二叉树括号表示法的字符串生成链式结构
     - 正确的字符串有四类字符，对应四种情况：
       1. 单个字符：data值
       2. （  ：一棵左子树的开始
       3.   ）：一棵子树的结束
       4.  ， ：一棵右子树的开始
     
   - 算法设计：
     1. 先创造根节点N，然后左子树L，最后右子树R，构造右子树的时候保存根节点N，根节点按最近保存的值匹配，因此用栈保存N
     
     2. 用char 类型变量ch扫描字符串，有以下种情况
        1. ch=='('，意味着前面的节点有孩子节点，因作为双亲节点进栈，置k为1，表示处理左孩子节点
        2. ch==')'，表示最近根节点的两个孩子节点处理完毕，退栈
        3. ch==','，表示后面是右子树，置k为2，处理右子节点
        4. ch不等于上面三种字符，即为节点值。
           - 创建*p存放ch
           - k=1，左孩子节点用*p赋值
           - k=2，右孩子节点用*p赋值
        
        - 例：字符串为A(B(D(,G)),C(E,F))，处理过程如下：
          1. ch==A，创建节点，data赋值A
          2. ch==(，表示A有孩子节点，A进栈，k赋值1
          3. ch==B，创建节点，栈顶元素为A说明B是A的孩子节点，此时k=1，为左孩子节点
          4. ch==（，B有孩子节点，B进栈，k赋值1
          5. ch==D，创建节点，栈顶元素为B说明D是B的孩子节点，此时k=1，为左孩子节点
          6. ch==（，D有孩子节点，D进栈，k赋值1
          7. ch== ,  ，表示下面是栈顶元素的右孩子节点，k赋值2
          8. ch==G，创建节点，栈顶元素为D说明G是D的孩子节点，此时k=2，为右孩子节点
          9. ch==)  ，表示栈顶节点的孩子节点处理完毕，栈顶退栈
          10. ch==)  ，表示栈顶节点的孩子节点处理完毕，栈顶退栈
          11. ch== ,  ，表示下面是栈顶元素的右孩子节点，k赋值2
          12. 略
     
   - ~~~ c
     void CreatBTNode(BTNode *&b,char *str){
         BTNode *St[MaxSize],*p;//St是栈
         int top=-1;//栈顶指针
         int j=0,k;
         char ch;
         b=NULL;//创建时置b为空
         //下面扫描str
         ch=str[j];
         while(ch!='\n'){
             switch(ch){
                 case '(' : top++;St[top]=p;k=1;break;
                 case ')' : top--;break;
                 case ',' : k=2;break;
                 default  : p=(BTNode *)malloc(sizeof(BTNode));
                     p->data=ch;p->lchild=p->rchild=NULL;
                     if(b==NULL){//若根节点还没有创建则创建根节点
                     	b=p;
                     }
                     else {
                         switch(k){
                             case 1:St[top]->lchild=p;break;
                             case 2:St[top]->rchild=p;break;
                         }
                     }
             }
             j++;ch=str[j];
         }
     }
     ~~~

2. 销毁二叉树

   - 算法设计：先删除左子树，再删除右子树，对于每棵子树作同样处理，直到根节点为空

   - ~~~ c
     void DestroyBT(BTNode *&b){
         if(b==NULL) return ;
         else {
             DestroyBT(b->lchild);
             DestroyBT(b->rchild);
             free(b);
         }
     }
     ~~~

3. 查找节点值

   - 找值为x的节点并返回其指针，所有节点值在二叉树中唯一

   - 递归模型：<img src="C:\Users\25024\Desktop\数据结构\image-20221107211556138.png" alt="image-20221107211556138" style="zoom:33%;" />

   - ~~~ c
     BTNode *FindNode(BTNode *b,ElemType x){
         if(b==NULL)return NULL;
         else if(b->data==x)return b;
         else {
             BTNode *p=FindNode(b->lchild,x);
             if(p!=NULL)return p;
             else p=FindNode(b->rchile,x);
         }
     }
     ~~~

4. 找孩子节点

   略

5. 求高度

   - 递归模型：<img src="C:\Users\25024\Desktop\数据结构\image-20221107211642907.png" alt="image-20221107211642907" style="zoom:33%;" />

   - ~~~ c
     int BTNodeDeepth(BTNdode *p){
         int lcdeep,rcdeep;//左右子树高度
         if(b==NULL)return 0;
         else {
             lcdeep=BTNodeDeepth(b->lchild);
             rcdeep=BTNodeDeepth(b->rchild);
             return (lcdeep>rcdeep)?(lcdeep+1),(rcdeep+1);
         }
     }
     ~~~

6. 输出

   - 同样采取递归的思路，把树这一结构转回成字符串

   - ~~~ c
     void DispBTNode(BTNode *b){
         if(b!=NULL){
             printf("%c",b->data);
             if(b->lchild!=NULL||b->rchild!=NULL){
                 printf("(");
                 DispBTNode(b->lchild);
                 if(b->rchild!=NULL)printf(",");
                 DispBTNode(b->rchild);
                 printf(")");
             }
         }
     }
     ~~~

### 二叉树的遍历

- 遍历是指按照某一顺序访问树中每个节点，且每个节点只访问一次

- 只考虑

  1. NLR	也叫先序遍历

     1. 访问根节点
     2. 先序遍历左子树
     3. 先序遍历右子树

     <img src="C:\Users\25024\Desktop\数据结构\image-20221113183345151.png" alt="image-20221113183345151" style="zoom:25%;" />

     如图，遍历顺序为：ABDGCEF

  2. LNR 

     1. 中序遍历左子树
     2. 访问根节点
     3. 中序遍历右子树

  3. LRN
  
     - <img src="C:\Users\25024\Desktop\数据结构\image-20221116162904827.png" alt="image-20221116162904827" style="zoom:15%;" />
  
  4. LRN
  
     - 最后访问根节点

### 遍历实现

1. 先序遍历

   - ~~~ c
     void PreOrder(BTNode *b){
         if(b!=NULL)
             printf("%c",b->data);
         PreOrder(b->lchild);
         PreOrder(b->rchild);
     }
     ~~~

2. 中序遍历

   - ~~~c
     void InOrder(BTNode *b){
         if(b!=NULL){
             InOrder(b->lchild);
             printf("%c",b->data);
             InOrder(b->rchild);
         }
     }
     ~~~

3. 后序遍历

   - ~~~ c
     void PostOrder(BTNode *b){
         if(b!=NULL){
             PostOrder(b->lchild);
             PostOrder(b->rchild);
             printf("%c",b->data);
         }
     }
     ~~~

4. 非递归（层次）遍历

   - 按照从上到下，从左到右的顺序依次访问每个节点

   - 顺序：

     1. 根节点进队
     2. 队不空时循环：出队一个元素p，访问（输出p），若有左子节点将左子节点进队，若有右子节点将右子节点进队

   - 巧妙之处在于，如此操作恰好满足所要求的顺序

   - ~~~ c
     void LevelOrder(BTNode *b){
         BTNode *p;
         BTNode *qu[MaxSize];
         int front=0,rear=0;
         qu[++rear]=b;
         while(rear!=front){
             front=(front+1)%MaxSize;
             p=qu[front];
             printf("%c ",p->data);
             if(p->lchild!=NULL){
                 rear=(rear+1)%MaxSize;
                 qu[rear]=p->lchild;
             }
             if(p->rchild!=NULL){
                 rear=(rear+1)%MaxSize;
                 qu[rear]=p->rchild;
             }
         }
     }
     ~~~

   - 算法的时间复杂度为O(n)

5. 例题：

   1. 设计一个算法level（）求b中节点值为x所在节点的层次

      - 不同于常规递归算法越往下递归级数越低（返回值return次数），本题越往下递归级数越高，因此需要在函数参数中设置一个计数器
      - 递归模型：
        1. 在当前节点找到x，return h；
        2. 在当前节点没找到，在左（右）子树中找到，左（右）子树的返回值是t，return t；
        3. 都没找到，return 0；

      ~~~c
      int level(BTNode *b,char x,int h){
          if(b==NULL)return 0;
          if(b->data==x)return h;
          int L=level(b->lchild,x,h+1);
          if(L!=0)
              return L;
          else{
              L=level(b->rchild,x,h+1);
              if(L!=0)
                  return L;
          }
          return 0;
      }
      ~~~

   2. 第9周第二讲6'57"




### 二叉树的构造

- 定理：同时给定一棵二叉树的先序和中序序列或中序和后序序列，可以唯一确定一棵二叉树（二叉树所有节点值不重复）
- 剩下见第九周第三讲



### 线索二叉树

- 在一棵二叉树中，有很多节点的指针域是空的，把这些空指针域利用起来，空左孩子节点指针域指向当前遍历方式中当前节点的前驱节点，空右孩子节点指针域指向当前遍历方式中当前节点的后继节点。
- 因此，需要添加标志来告诉我们某一 节点的某一孩子节点是否为空，左孩子节点添加ltag，右孩子节点添加rtag，为0说明对应指针为空

建立方式：

- 以该遍历方式遍历当前树，在遍历的过程中检查当前节点的左右孩子节点是否为空
- 左孩子节点为空，则改为本节点的前驱节点
- 右孩子节点为空，则改为本节点的后继节点

建立的实现：第九周第四讲5'30"

遍历线索二叉树：

1. 先找到开始的节点：从根节点开始，一直b->lchild，直到b->lchild为空
2. 访问当前节点
3. 从当前节点开始，循环访问右孩子节点，直到右孩子节点不是线索为止
4. 此时，当前节点是一颗子树，用1的方法找到开始节点，然后再循环访问右孩子节点，直到其不是线索回到1

遍历的实现：第九周第四讲9'45"





## 哈夫曼树

### 相关定义

- 带权路径长度：设二叉树具有n个带权值的叶子节点，从跟节点到各个叶子节点的路劲长度与权值的积的和，叫做二叉树的带权路径长度，记作WPL
- 哈夫曼树：具有最小带权路径长度的树，也叫最优树

### 构造哈夫曼树

- 原则：权值越大越靠近根节点，权值越小越远离根节点
- 过程：设权值分别为{w1,w2,w3......wn}
  1. 用他们构造只有单个节点的树F={T1,T2,T3......Tn}
  2. 选出F中最小和次小的两个节点作为左右孩子节点，构成新的节点，新节点的值为他们两个节点值的和
  3. 在F中删除2中选过的节点，加入2中生成的新节点
  4. 重复2和3两步直到F只有一个节点（数），这棵树就是哈夫曼树

### 哈弗曼编码

- 哈夫曼编码为二进制编码
- 把哈夫曼树中的所有左子节点改成0，右子节点改成1
- 某***叶子***节点对应的哈夫曼编码即为从根节点开始到该位置的路径
- 权值越大哈夫曼编码越短，反之越长
- 因为是叶子节点的编码，所以一组哈夫曼编码中不可能存在某个编码是另一个编码的前缀这种情况否则为前缀的节点不是叶子节点


# 文件存储位置

C:\Users\25024\Desktop\数据结构\文件名

